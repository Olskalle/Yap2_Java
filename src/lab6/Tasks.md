# ЛАБОРАТОРНАЯ РАБОТА №6

## Распределение вариантов
| №варианта | №1 | №2 | №3 | №4 |
|:---------:|:--:|:--:|:--:|:--:|
|1          | 3  |1-6 | 3  | 1  |

## 1. Рефлексия. Кэширование.
Разработайте обобщенный утилитный метод cache. Метод принимает объект и возвращает такую версию
данного объекта, у которого вызовы всех методов без параметров (доступных по текущей ссылке)
кэшированы. При вызове кэшированного метода необходимо проанализировать состояние объекта:
* Если метод вызывается впервые после создания кэшированного объекта - то он вызывается обычным образом.
* Если метод вызывается повторно и с момента прошлого вызова внесены изменения в состояние объекта – то он вызывается обычным образом.
* Если метод вызывается повторно и объект не был изменен с момента прошлого вызова – то вместо вызова метода необходимо вернуть то же значение, что возвращал метод при предыдущем вызове.

При разработке метода необходимо учесть следующее:
* Метод принимает объект обобщенного типа T и возвращает объект того же типа.
* Если объект приходит по интерфейсной ссылке – то кэшируются все методы этой ссылки, а объект должен реализовывать этот интерфейс
* Если объект приходит по классовой ссылке – то кэшируются только публичные методы, а объект должен быть подклассом исходного класса
* Кэшированию подлежат только методы без входных параметров

На рисунке дан пример результата кэширования для объекта класса A. 
В 28 строчке текст “original method” не выведен на экран, так как с момента последнего вызова метода
cacheTest объект не изменился, и следовательно возвращается кэшированное значение.
Задача имеет повышенную сложность.

``` java
class A {
String stringField;
    public A(String str) { 
        stringField = str;
    }

    public int cacheTest () {
        System.out.println("original method");
        return 42;
    }
}
```
``` java
A a= cache(new A("first")); 
System.out.println (a.cacheTest());
// вывод: original method 42

a.stringField="second";
System.out.println(a.cacheTest ());
// вывод: original method 42

System.out.println(a.cacheTest()); 
// вывод: 42
```

## 2 Аннотации

### 2.1 @Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
* Целью может быть только МЕТОД
* Доступна во время исполнения программы
* Не имеет свойств
Проаннотируйте какой-либо метод данной аннотацией.

### 2.2 @Default.
Разработайте аннотацию @Default, со следующими характеристиками:
* Целью может быть ТИП или ПОЛЕ
* Доступна во время исполнения программы
* Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией.

### 2.3 @ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
* Целью может быть ТИП или ПОЛЕ
* Доступна во время исполнения программы
* Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
* Значение свойства по умолчанию: YES
Проаннотируйте какой-либо класс данной аннотацией.

### 2.4 @Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
* Целью может быть ТИП или АННОТАЦИЯ
* Доступна во время исполнения программы
* Имеет обязательное свойство value, типа Class[]
Проаннотируйте какой-либо класс данной аннотацией.

### 2.5 @Two.
Разработайте аннотацию @Two, со следующими характеристиками:
* Целью может быть ТИП
* Доступна во время исполнения программы
* Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс данной аннотацией.

### 2.6 @Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
* Целью может быть ТИП
* Доступна во время исполнения программы
* Имеет необязательное свойство value, типа String[]
* Значение свойства по умолчанию: пустой массив
Проаннотируйте какой-либо класс данной аннотацией.

## 3 Обработка аннотаций. Кэширование.
Измените утилитный метод cache из задачи 1.3. Теперь метод должен принимать произвольный набор объектов по ссылкам типа Object. 
Кэширование выполняется только для тех объектов, которые проаннотированы с помощью @Cache из предыдущей задачи, при этом:
* Если для аннотации не заданы параметры, то кэширование выполняется как обычно.
* Если для аннотации задан набор строк, то их необходимо учитывать как названия методов
подлежащих кэшированию. Остальные методы – не кэшируются.


## 4 Тестирование
Напишите тест, используя фреймворк **juntil**, к методу из задания 3. Пояснения к тесту и объекту
тестирования отобразить в комментариях кода и в отчете.